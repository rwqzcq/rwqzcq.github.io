---
title: 5月11日工作内容
date: 2021-05-11 16:37:49
tags:
 - 实习
categories:
 - 金山实习
---

# 工作内容

1. 学习leader做的excel中月度数据复盘，学习其制作的方式。

# 分析

1. 难度较大，涉及到大量的SQL语句与Excel函数操作。

# 学习的知识点

## 大盘留存率

某一个时间段内大盘的留存率不区分`版本、国家`。比如下面一段SQL就是计算留存率。

```sql
SELECT
    week,
    'all' as first_open_version,
    'all' as country,
    SUM(week0),
    SUM(week1)
FROM
    `wps-data-analysis.wps_active.android_retentions_weekly_ratio`
WHERE
    week >= "2021-02-15" 
GROUP BY
    week,
    country,
    first_open_version 
```
按照传统的SQL执行顺序为`from->where->group by->select`，这一段代码放到`mysql`中会报错，如果在mysql应该这样写：

```sql
select
    week,
    'all' as first_open_version,
    'all' as country,
    SUM(week0),
    SUM(week1)
from (
    SELECT
        week,
        'all' as first_open_version,
        'all' as country,
        week0,
        week1
    FROM
        `wps-data-analysis.wps_active.android_retentions_weekly_ratio`
    WHERE
        week >= "2021-02-15"
) as a
group by
    week,
    first_open_version,
    country
order by 
    week,
    first_open_version,
    country

```
更简便的写法为
```sql
    select
        week,
        'all' as first_open_version,
        'all' as country,
        sum(week0),
        sum(week1)
    from
        `wps-data-analysis.wps_active.android_retentions_weekly_ratio`
    where
        week >= '2021-02-15'
    group by
        week
    order by week
```
这个就又涉及到了hiveSQL的执行顺序
> from->join->where->select->group by->having

这个涉及到了Hadoop中的`Map-Reduce操作`。上面的select属于`Map阶段`，而最后输出的数据属于 `Reduce`中的select操作。

```TXT
在map阶段
    from 加载，进行表的查找和加载
    where过滤
    select查询
    group by 执行分组后的相关计算
    map端文件合并

在Reduce阶段
    group by :对map端发来的文件进行合并
    select : 过滤列用于输出结果
    limit排序
```

## 分版本计算

还是涉及到hiveSQL的执行顺序。
```sql
    -- 日本分版本
    select 
        week,
        left(first_open_version, 4) as version, -- 这里需要注意
        'Thailand' as country,
        week_interval,
        sum(retentions) as retentions
    from
        `wps-data-analysis.wps_metric_android.android_retentions_weekly`
    where
        week >= "2021-02-15" and
        week_interval in (0, 1) and
        country in ('Thailand') and 
        first_open_version >= '13.0' and first_open_version <= '14.0.0'
    group by version, week, week_interval
    order by version, week, week_interval
```
由于hivesql的执行顺序为`select->group`，因此根据`left(first_open_version, 4)`来分组的话别名要起到select里面，然后在`group by`中应用。

## EXCEL SUNIFS多条件区域求和与$绝对引用

在用excel计算留存率的时候，需要分国家、分版本来计算留存率，如下图所示。
![](/images/wps_retention_weekly_excel.png)

这个时候需要在一个新的sheet中去按照版本与国家来计算每一个日期的周留存率。结果如下图所示：
![](/images/wps_retention_weekly_result_excel.png)
此时的目标就是通过计算出一个cell然后通过拖拽来实现计算所有的cell。实现此步骤主要使用的是两个要点为
- sumifs 多条件筛选求和
- $绝对引用

原来的写法：
```excel
=SUMIFS(data!E:E,data!A:A,A4,data!B:B,B2,data!C:C,B1)/SUMIFS(data!D:D,data!A:A,A4,data!B:B,B2,data!C:C,B1)
```
这样的写法并不能够拖拽。
因为拖拽的时候对应的数据项会偏移，原来的做法是再去增加一行，然后再去拖拽，让excel去智能识别我的`筛选条件固定的`，也就是我查找的区域是不变的。
这个时候就要用到`$`表示绝对引用。解释如下:
> $是绝对引用的意思。比如你公式中使用A1，那么你使用拖动填充公式的时候，如果往下填充，下一条公式会自动变成A2，如果往右，会自动变成B1。
> 如果你公式中使用$A$1，那么拖动填充的时候这个引用就不会变化。A$1这样是行不会变化，$A1是列不会变化。    

`A$1这样是行不会变化，$A1是列不会变化。`我的理解是向左右拖拽的时候`A$1`,这样不会发生变化，但是向上向下会发生变化，同理，`$A1`代表着上下拖拽的时候，引用的值不会发生变化，
如果就是让行列都不发生变化的话，使用`$A$1`。

正确的写法：
```excel
SUMIFS(data!$E:$E,data!$A:$A,$A4,data!$B:$B,B$2,data!$C:$C,B$1)/SUMIFS(data!$D:$D,data!$A:$A,$A4,data!$B:$B,B$2,data!$C:$C,B$1)
```
由于要定位的数据的区域、筛选的数据的区域是固定的，因此需要加上绝对引用，如`data!$E:$E`，上下拖拽(列不变，行变)不改变要检索的值，而左右拖拽(行不变，列变)需要改变检索的值。
这个时候在检索的值就需要写成
- `$A4`，也就是date，左右拖拽不变，上下拖拽变 -> 列不变，行变。
- `C$2`，也就是version，上下拖拽不变，左右拖拽变 -> 行不变，列变。

> 容易的记法是$向右挨着谁，谁变。先行后列。


## EECEL $ 绝对引用

# 参考链接
1. 执行顺序https://www.cnblogs.com/jiangxiaoxian/p/7155636.html
2. 执行顺序https://www.jianshu.com/p/7198782c291b
3. 绝对引用https://zhidao.baidu.com/question/554518715.html