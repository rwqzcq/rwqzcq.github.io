---
title: 5月8日实习日志
date: 2021-05-08 10:53:27
tags:
 - 实习
categories:
 - 金山实习
---

# 工作内容

完成三个安卓版本`13.5`, `13.6`, `13.7`，在`2021年2月26号`到`2021年4月18号`，也就是在每一个版本上线的第4天到第20天，以周为单位，观察安卓版本用户在`分享行为`的留存率的变化。

通过编写SQL语句完成数据的提取，包括
1. 总体留存
2. 文件分享(as_file)行为留存
3. 链接分享(as_link)行为留存

最后将这些留存数据合并成一张excel，利用`offset函数`计算其留存率，并绘制不同版本的留存率图。

# 分析

这次的任务对我而言有一定的难度，因为对于这个表结构的不熟悉以及对于Leader的SQL代码的不熟悉，导致出现了很多的问题，有
1. 在计算的`as_file`留存率，出现了明显得错误，大于1。
2. 对于Leader 的sql照抄而没有一个很好的改进。

# 表结构

![](/images/wps_active_android_core_share_feature_table_structure.png)

该表以日期的形式记录了每一个用户在特定的日期内在某一个版本的安卓APP中触发分享行为，其中具体的分享行为包括
1. if_show(分享页面展示)
2. as_file(以文件的形式分享,记录的是当天分享的次数)
3. as_link(以链接的形式分享,记录的是当天分享的次数)
4. if_click(是否点击，点击任意位置都会被记录)

数据举例:
![](/images/wps_active_android_core_share_feature_demo_data.png)

# 业务指标计算

## 计算总体的周留存率

### 概念解析

> 周留存 = 本周仍然使用分享功能的用户 / 上一周使用分享功能的用户

需要注意的是周的概念：比如在周二使用的用户，那么在下一个周期(7天)仍然使用了分享功能，那么这个就计算为一次留存。但是在我们的这个业务中，周不严格地区分天数，也就是说，
`上一周任意一天分享地用户在下一周任意一天分享，都会记录为一次留存`，关于留存率的详细链接参考[这里](http://www.gupowang.com/article/view/5099)。

#### 代码

```sql
-- 开启两个子查询
with yesterday as (
    select
        distinct date,
        google_id,
        left(version, 4) as version
    from
        `wps-data-analysis.wps_active.android_core_feature_share`
    where
        left(version, 4) in ('13.5', '13.6', '13.7') and
        date between '2021-02-26' and '2021-04-18'
),
today as (
    select
        distinct date,
        google_id,
        left(version, 4) as version
    from
        `wps-data-analysis.wps_active.android_core_feature_share`
    where
        left(version, 4) in ('13.5', '13.6', '13.7') and
        date between '2021-02-26' and '2021-04-18'   
)

-- 计算留存

select
    b.google_id,
    b.google_id,
    b.version,
    date_trunc(a.date, week) as week,
    date_diff(b.date, a.date, week) as time_interval -- 计算时间差 是在一周内的，还是在下一周的
from 
    yesterday as a
inner join 
    today as b
on 
    a.google_id = b.google_id and
    b.version = a.version and
    date_diff(b.date, a.date, week) in (0,1) -- 核心 也就是说两个表里面差1周或者差0周会被链接

```

## 计算文件|链接分享的周留存率

### 一般写法

```sql

with yesterday as (
    select
        date,
        google_id,
        version
        -- 这里不需要再次count，已经有过分享行为了，在一天之内，不管分享了几次，都算当天分享
    from (
        select
            date,
            google_id,
            left(version, 4) as version,
            as_file
        from
            `wps-data-analysis.wps_active.android_core_feature_share`
        where
            left(version, 4) in ('13.5', '13.6', '13.7') and
            date between '2021-02-26' and '2021-04-18' and
            as_file > 0 -- 有过分享行为 
    ) as a
    group by date, google_id, version
),
today as (
    select
        date,
        google_id,
        version
        -- 这里不需要再次count，已经有过分享行为了，在一天之内，不管分享了几次，都算当天分享
    from (
        select
            date,
            google_id,
            left(version, 4) as version,
            as_file
        from
            `wps-data-analysis.wps_active.android_core_feature_share`
        where
            left(version, 4) in ('13.5', '13.6', '13.7') and
            date between '2021-02-26' and '2021-04-18' and
            as_file > 0 -- 有过分享行为 
    ) as a
    group by date, google_id, version
)

-- 计算留存

select
    b.version,
    date_trunc(a.date, week) as week,
    date_diff(b.date, a.date, week) as time_interval -- 计算时间差 是在一周内的，还是在下一周的
    count(distinct google_id) as retentional -- 这里需要用到distinct
from 
    yesterday as a
inner join 
    today as b
on 
    a.google_id = b.google_id and
    b.version = a.version and
    date_diff(b.date, a.date, week) in (0,1) -- 核心 也就是说两个表里面差1周或者差0周会被拼接在一起
group by 
    b.version,
    week, -- 这里的执行顺序需要注意
    time_interval
```

### 优化写法

```sql

-- 开启两个子查询
with yesterday as (
    select
        distinct date,
        google_id,
        left(version, 4) as version
    from
        `wps-data-analysis.wps_active.android_core_feature_share`
    where
        left(version, 4) in ('13.5', '13.6', '13.7') and
        date between '2021-02-26' and '2021-04-18'
),
today as (
    select
        distinct date,
        google_id,
        left(version, 4) as version
    from
        `wps-data-analysis.wps_active.android_core_feature_share`
    where
        left(version, 4) in ('13.5', '13.6', '13.7') and
        date between '2021-02-26' and '2021-04-18'   
)

-- 计算留存

select
    b.google_id,
    b.google_id,
    b.version,
    date_trunc(a.date, week) as week,
    date_diff(b.date, a.date, week) as time_interval -- 计算时间差 是在一周内的，还是在下一周的
from 
    yesterday as a
inner join 
    today as b
on 
    a.google_id = b.google_id and
    b.version = a.version and
    date_diff(b.date, a.date, week) in (0,1) -- 核心 也就是说两个表里面差1周或者差0周会被链接

```

## 计算文件|链接分享的周留存率

### 一般写法

```sql

with yesterday as (
    select
        date,
        google_id,
        left(version, 4) as version
    from
        `wps-data-analysis.wps_active.android_core_feature_share`
    where
        left(version, 4) in ('13.5', '13.6', '13.7') and
        date between '2021-02-26' and '2021-04-18' and
        as_file > 0 -- 有过分享行为 
    group by date, google_id, left(version, 4)
),
today as (
    select
        date,
        google_id,
        left(version, 4) as version
    from
        `wps-data-analysis.wps_active.android_core_feature_share`
    where
        left(version, 4) in ('13.5', '13.6', '13.7') and
        date between '2021-02-26' and '2021-04-18' and
        as_file > 0 -- 有过分享行为 
    group by date, google_id, left(version, 4)
)

-- 计算留存
select
    b.version,
    date_trunc(a.date, week) as week,
    date_diff(b.date, a.date, week) as time_interval -- 计算时间差 是在一周内的，还是在下一周的
    count(distinct google_id) as retentional -- 这里需要用到distinct
from 
    yesterday as a
inner join 
    today as b
on 
    a.google_id = b.google_id and
    b.version = a.version and
    date_diff(b.date, a.date, week) in (0,1) -- 核心 也就是说两个表里面差1周或者差0周会被拼接在一起
group by 
    b.version,
    week, -- 这里的执行顺序需要注意
    time_interval
```


## 计算分享的周留存率

# 学习要点

1. distinct

distinct约束的是distinct后面所有的字段的值，而不是单单约束其中的一个。
比如`select distinct A, B, C from table1`。
其执行顺序为:
1. 从table1中筛选出`A B C`三列。
2. 再对包含`A B C`列进行去重，其中必须要保证`A B C`三列中全部要重复才能去重，否则该约束会失败。

`distinct A, B, C`就相当于`distinct (A, B, C)`,
所以要想多列对某一个字段去重，则需要`group by`,
由于用户在一天之内可能进行多次文件分享的操作，每一次点击的次数可能不唯一，因此需要用到`group by`,把用户一天之内进行的多次操作全部置为1次操作，
因此我感觉这个脚本写得可能有问题，既然是按日期精确到某一天了，就不太可能会出现一天之内进行的重复操作了。因此<span style="color:red;font-weight:bold;">需要研究写该SQL的原始代码</span>。

2. date_diff函数

date_diff函数是BigQuery中的语法，为了计算两个日期之间的差，差值的单位可以是`month week year`,这段SQL中需要注意的是日期的前后顺序，`date_diff(b.date, a.date, week)`，b的日期要晚于a的日期，所以
其差值为非负数。

3. hive SQL 执行顺序

> from->join->where->group by->having->select->order->limit

```sql
select
    b.version,
    date_trunc(a.date, week) as week,
    date_diff(b.date, a.date, week) as time_interval -- 计算时间差 是在一周内的，还是在下一周的
    count(distinct google_id) as retentional -- 这里需要用到distinct
from 
    yesterday as a
inner join 
    today as b
on 
    a.google_id = b.google_id and
    b.version = a.version and
    date_diff(b.date, a.date, week) in (0,1) -- 核心 也就是说两个表里面差1周或者差0周会被拼接在一起
group by 
    b.version,
    week, -- 这里的执行顺序需要注意
    time_interval
```
上面的代码在`group by`中所使用的字段是在`select`中也出现的，我的一个猜想可能是某一种同步的机制，我group by的字段那么也要在selcet中出现，这个时候可以做到关联。



# 未来学习的方向

1. 如何在excel中使用`数据透视表`完成留存率的计算。
2. hiveSQL的执行顺序

